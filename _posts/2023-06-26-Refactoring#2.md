---
layout: post
title: 기본적인 Refactoring 
subtitle: 마틴 파울러의 리팩토링 2판 정리
categories: Refactoring
tags: [Refactoring]
---

이번 장에서는 리팩토링 방법들에 대해 설명한다.

## 1. 함수 추출하기  
코드를 보고 무슨 일을 하는지 파악하는데 한참이 걸린다면 그 부분을 함수로 추출한 뒤 '무슨 일'에 걸맞는 이름을 짓는다.  

*함수를 짧게 만들면 함수 초루이 많아져서 성능이 느려질까 걱정하는 사람도 있다. 함수가 짧으면 캐싱하기가 더 쉽기 때문에 컴파일러가 최적화하는데 유리할 때가 많다*

## 2. 함수 인라인하기  
간접 호출을 너무 과하게 쓰는 코드도 인라인 대상이다.   
*인라인하려고 하는 함수가 polymorphism method 인지 확인한다 : 서브클래스에서 오버라이드하는 메서드는 인라인하면 안된다*

## 3. 변수 추출하기  
지역 변수를 활용하면 표현식을 쪼개 관리하기 더 쉽게 만들 수 있다. 이 과정에서 추가한 변수는 디버깅에도 도움된다.  

## 4. 변수 인라인하기  
변수가 표현식과 다를 바가 없을떄는 그 변수를 인라인하는 것이 좋다.  
```java
int itemPrice = item.price;
return itemPrice;
```
위와 같이 표현식이 명확할 때는 아래처럼 인라인하는 것이 낫다.  

```java
return item.price;
```

## 5. 함수 선언 바꾸기  
- 메서드명 변경  
함수가 무슨 일을 하는지 이름만 보고 알 수 있어야한다. 그래야 코드를 다시 볼 때 무슨 일을 하는지 '또' 고민하지 않게 된다.  
- 매개변수 추가 또는 변경  
이 문제는 정답이 없다. 매개변수로 객체가 전달될때 함수의 활용 범위를 넓힐 수 있지만 필요없는 정보를 전달해서 객체의 인터페이스와 결합돼버린다.

## 6. 변수 캡슐화하기
데이터 캡슐화는 데이터를 변경하고 사용하는 코드를 감시할 수 있는 확실한 통로가 되어주기 때문에 데이터 변경 전 검증이나 변경 후 출가 로직을 쉽게 끼워 넣을 수 있다.  
*책에서는 객체 지향에서 객체의 데이터를 항상 private 으로 유지해야한다고 말한다.*
- 값 캡슐화하기  
변수에 담긴 내용을 수정하는 것까지 캡슐화하고 싶을때, 간단한 첫번째 방법은 그 값을 바꿀 수 없게 만드는 것이다.

```java
BookData defaultBook = new BookData("Title1");
BookData BookData()
{
    return new BookData(defaultBook);
}
```
이렇게 하면 BookData() 함수로는 defaultBook 의 데이터를 새로운 객체가 return 되므로 원본에 아무 영향을 주지 못한다. 

## 7. 변수 이름 바꾸기  
명확한 프로그래밍의 핵심은 이름짓기이다. 제대로 된 이름을 짓지 못한 이유는 고민을 충분히 하지 않았거나 사용자의 요구가 변해 프로그램이 목적이 변했기 떄문이다.
```java
int a = (priceA + priceB + priceC)/3;
```
위 예시로는 a만 봐서는 무슨 변수인지 유추할 수 없으므로 변수 이름을 아래처럼 변경해주는 것이 명확하다.
```java
int avgPrice = (priceA + priceB + priceC)/3;
```
이렇게 변경된 변수가 여러 곳에서 쓰이고 있다면 변수 캡슐화하기를 고려한다. 변경된 변수를 참조하는 곳을 찾아서 하나씩 변경해준다.  

## 8. 매개변수 객체 만들기

데이터 항목 여러 개가 함께 몰려다니는 무리를 발견하면 데이터 구조 하나로 모아준다. 함수의 매개변수로 이 데이터 구조를 받게 하면 매개변수 수가 줄어든다.
```java
boolean IsPriceinRange(int price, int minPrice, int maxPrice)
{
    return (price >= minPrice && price <= maxPrice);
}
```  

위와 같은 코드는 매개변수가 총 3개이지만, temp_min,temp_max 는 항상 동시에 체크되므로 객체화할 수 있다.  

```java
boolean isPriceInRange(int price, PriceRange priceRange)
{
    return (price >= priceRange.minPrice && temp <= priceRange.maxPrice);
}
```  
## 9. 여러 함수를 클래스로 묶기
공통의 매개변수를 중심으로 작동하는 함수 무리를 발견하면 클래스로 묶어준다. 이렇게 하면 파생 객체들을 일관되게 관리할 수 있고 클라이언트가 객체의 핵심 데이터를 변경할 수 있다. 

```java
boolean isPriceInRange();
boolean 
```  



## 10. 여러 함수를 변환 함수로 묶기  
변환 함수는 원본 데이터를 입력 받아서 필요한 정보를 도출하고 각각을 출력 데이터의 필드에 넣어 반환한다. 여러 함수를 변환 함수로 추출하면 도출 로직의 중복을 막고 쉽게 찾아 쓸 수 있다. (데이터 구조와 이를 사용하는 함수가 근처에 있지 않으면 함수를 발견하기 어려울 때가 많은데 변환 함수로 묶으면 쉽게 찾아 쓸 수 있다.)  

## 11. 단계 쪼개기
코드에서 서로 다른 일을 할 때 각각을 별개의 모듈로 분리한다.  
* 두번째 단계에 해당하는 코드를 함수로 추출하고
* 테스트 한다.
* 중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가한다.
* 테스트 한다.
* 추출한 두번째 단계 함수의 매개변수를 하나씩 검토한다. 그 중 첫번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다.
* 첫번째 단계 코드를 함수로 추출하면서 중간 데이터 구조를 반환하도록 만든다.

