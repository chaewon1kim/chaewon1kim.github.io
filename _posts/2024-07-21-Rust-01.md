---
layout: post
title: 소유권 이해하기
subtitle: 러스트 프로그래밍 공식 가이드 제2판
categories: Rust
tags: [RustProgramming]
---

## 소유권이란?
소유권은 러스트에서 사용하는 메모리 관리법 규칙 모음을 말한다.

소유권 규칙
- 각각의 값은 owner가 있다
- 한 값의 소유자는 동시에 여럿 존재할 수 없습니다.
- 소유자가 스코프 밖으로 벗어날 떄, 값은 버려집니다.

```rust
let s1 = String::from("Hello");
let s2 = s1;
//s1 is not valid from this line
println!("{},World", s1);
```  
위 코드에서는 s2 에 s1의 포인터,길이,크기만 가져왔으므로 얇은 복사(shallow copy) 라고 생각할 수 있지만, 러스트에서는 s1을 무효화 시키므로 이동되었다(move) 고 한다. 
힙 데이터까지 복사하고 싶을 때는 clone 함수를 사용한다.

## 소유권과 함수

```rust
fn main() {
    let s = String::from("hello");  // s가 스코프 안으로 들어왔습니다.

    takes_ownership(s);             // s의 값이 함수 안으로 이동했습니다...
                                    // ... 그리고 이제 더이상 유효하지 않습니다.
    let x = 5;                      // x가 스코프 안으로 들어왔습니다.

    makes_copy(x);                  // x가 함수 안으로 이동했습니다만,
                                    // i32는 Copy가 되므로, x를 이후에 계속
                                    // 사용해도 됩니다.

} // 여기서 x는 스코프 밖으로 나가고, s도 그 후 나갑니다. 하지만 s는 이미 이동되었으므로,
  // 별다른 일이 발생하지 않습니다.

fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어왔습니다.
    println!("{}", some_string);
} // 여기서 some_string이 스코프 밖으로 벗어났고 `drop`이 호출됩니다. 메모리는
  // 해제되었습니다.

fn makes_copy(some_integer: i32) { // some_integer이 스코프 안으로 들어왔습니다.
    println!("{}", some_integer);
} // 여기서 some_integer가 스코프 밖으로 벗어났습니다. 별다른 일은 발생하지 않습니다.
```  

takes_ownership 이후에 s를 참조하려고 하면 컴파일 에러가 난다.


```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership은 반환값을 s1에게 이동시킵니다.

    let s2 = String::from("hello");     // s2가 스코프 안에 들어왔습니다.

    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back 안으로 이동되었고,
                                        // 이 함수가 반환값을 s3으로도 이동시켰습니다.

} // 여기서 s3는 스코프 밖으로 벗어났으며 drop이 호출됩니다. 
  // s2는 스코프 밖으로 벗어났지만 이동되었으므로 아무 일도 일어나지 않습니다. 
  // s1은 스코프 밖으로 벗어나서 drop이 호출됩니다.

fn gives_ownership() -> String {             // gives_ownership 함수가 반환 값을 호출한 쪽으로 이동시킵니다.

    let some_string = String::from("hello"); // some_string이 스코프 안에 들어왔습니다.

    some_string                              // some_string이 반환되고, 호출한 쪽의 함수로 이동됩니다.
}

// takes_and_gives_back 함수는 String을 하나 받아서 다른 하나를 반환합니다.
fn takes_and_gives_back(a_string: String) -> String { // a_string이 스코프 안으로 들어왔습니다.

    a_string  // a_string은 반환되고, 호출한 쪽의 함수로 이동됩니다.
}
```
takes_and_gives_back 을 통해서 s2 가 s3 으로 이동된다. 
(takes_and_gives_back 이후에 s2 를 참조할 수 없음)

## 참조와 대여
소유권을 주지 않고 값을 사용할 수 있는 참조자라는 기능을 알아보자
참조자(reference)는 해당 주소에 저장된 데이터에 접근할 수 있도록 해주는 주솟값에 해당하는, 포인터와 같은 것입니다.

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

&s1은 해당 값을 소유하지 않는 참조자를 생성하는데, 이런 행위를 대여(borrowing)이라고 합니다.
대여 시에는 값을 수정할 수 없습니다.

```rust
fn main() {
    let s1 = String::from("hello");

    change(&s1);
}

fn change(s: &String) -> usize {
    s.pust_str(", World!");
}
```

위 코드는 동작하지 않습니다. 기본적으로 변수는 불변이므로 참조자도 마찬가지로 불변의 속성을 가지고 있습니다.

## 가변 참조자

이 참조자를 수정하고 싶을때는 가변 참조자를 사용할 수 있습니다.

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
변수를 가변(mut)으로 만들어주고 참조자도 &mut s 로 생성해준다.
제약사항) 한 스코프 내에서는 가변 참조자를 딱 하나만 만들 수 있습니다.

```rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;
```
위와 같이 가변 참조자를 두 개 이상 만드는 것은 허용되지 않는 제약이 있어 컴파일 단계부터 데이터 경합(data race) 상황을 방지합니다.

데이터 경합은 아래 세가지 상황이 겹칠 때 일어나는 특수한 race 조건입니다.

- 둞 이상의 포인터가 동시에 같은 데이터에 접근
- 그 중 적어도 하나의 포인터가 데이터를 사용
- 데이터에 접근 동기화 메커니즘이 없음

```rust
let mut s = String::from("hello");

let r1 = &s; // 문제 없음
let r2 = &s; // 문제 없음
let r3 = &mut s; // 큰 문제
```

불변 참조자가 있는 동안 같은 값의 가변 참조자를 만드는 것 또한 불가능 합니다.

```rust
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &s; // 문제 없음
    let r2 = &s; // 문제 없음

    println!("R1 {}, R2 {}",r1,r2); 
    
    let r3 = &mut s; // 문제 없음

    println!("R3 {}",r3);   
}
```
불변 참조자가 마지막으로 사용되는 println! 문 이후에 가변 참조자가 생성되므로 위 코드에서는 컴파일 에러가 발생하지 않습니다.

## 댕글링 포인터(Dangling pointer)

댕글링 포인터란, 어떤 메모리를 가리키는 포인터가 남아 있는 상황에서 일부 메모리를 해제해버림으로써, 다른 개체가 할당받았을지도 모르는 메모리를 참조하게 된 포인터를 말합니다.

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle은 String의 참조자를 반환합니다

    let s = String::from("hello"); // s는 새로운 String입니다

    &s // 우리는 String s의 참조자를 반환합니다.
} // 여기서 s는 스코프를 벗어나고 버려집니다. 이것의 메모리는 사라집니다.
  // 위험하군요!
```

변수 s는 dangle 함수가 종료됨에 따라 버려지는데 이 메모리를 참조하는 &s를 반환하려고 해서 에러가 발생합니다. 이런 경우에는 String 을 직접 반환해야 합니다.

## 참조자 규칙
- 단 하나의 가변 참조자만 갖거나, 여러 개의 불변 참조자를 가질 수 있습니다.
- 참조자는 항상 유효해야 합니다.

## 슬라이스 타입

슬라이스(slice)는 컬렉션을 통째로 참조하는 것이 아닌, 컬렉션의 연속된 일련의 요소를 참조하도록 해줍니다. 슬라이스는 참조자의 일종으로 소유권을 갖지 않습니다.

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word는 5를 갖게 될 것입니다.

    s.clear(); // 이 코드는 String을 비워서 ""로 만들게 됩니다.

    // word는 여기서 여전히 5를 갖고 있지만, 5라는 값을 의미있게 쓸 수 있는 스트링은 이제 없습니다.
    // word는 이제 완전 유효하지 않습니다!
}

fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

위 코드의 first_word 함수에서 s의 첫번째 단어의 끝 위치 5를 찾았지만, s가 clear 되면서 내용물이 변경되어 원래 목적인 첫 단어를 추출하는 데 사용할 경우 에러를 발생시킬 수 있습니다.

이러한 문제의 해결책으로 문자열 슬라이스(string slice)를 사용합니다.

## 문자열 슬라이스(string slice)

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

* 문자열 슬라이스 사용방법

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[..]; //let slice = &s[0..len]; 랑 같음
let slice = &s[3..]; // let slice = &s[3..len]; 랑 같음
let slice = &s[..2]; //let slice = &s[0..2]; 랑 같음
```

기존 first word 함수를 문자열 위치가 아니라 문자열 슬라이스를 반환하도록 수정해보자.
```rust

fn first_word(s:&String) ->&str {

    let bytes = s.as_bytes();
    for(i, &item) in bytes.iter().enumerate()
    {
        if item == b' '
        {
            return &s[0..i];
        }

    }
    $s[..]
}
```

이제 first word 가 반환하는 값을 원래 데이터와 분리되어 있지 않으므로, 원래 데이터가 수정되면 컴파일 에러가 발생합니다.

- 스트링 리터럴도 슬라이스이다.

## 파라미터로서의 스트링 슬라이스
```rust
fn first_word(s: &String) -> &str {
```
위 코드는 아래 코드로 작성될 수 있다! 

```rust
fn first_word(s: &str) -> &str {
```

함수가 String 참조자 대신 스트링 슬라이스를 갖도록 정의하는 것은 API를 어떠한 기능적 손실 없이도 더 일반적이고 유용한 코드로 만들어줍니다.

## 정리
소유권, 대여, 슬라이스를 통해 러스트는 컴파일 타임에 메모리 안정성을 보장합니다. 컴파일 타임에 이를 제한하면서 프로그래머가 제어 코드를 작성하거나 디버깅하는 시간을 줄일 수 있습니다.