---
layout: post
title: 기능 이동
subtitle: 마틴 파울러의 리팩토링 2판 정리
categories: Refactoring
tags: [Refactoring]
---

## 1. 함수 옮기기  
함수를 옮기는 이유는 모듈성을 높이기 위해서이다. 모듈성을 높이면 함수를 고칠때 해당 기능과 관련된 작은 일부만 이해하고 있더라도 쉽게 가능하게 해준다. 함수가 모듈 A보다 모듈 B의 요소를 더 많이 이용하고 있다면 모듈 B로 옮겨줘야한다.
## 2. 필드 옮기기  
주어진 문제에 적합한 데이터 구조를 사용해야한다. 필드를 변경하려고 할때 여러군데를 고쳐야 한다면 한번만 갱신해도 되는 위치로 옮겨야한다. 
## 3. 문장을 함수로 옮기기  
특정 함수를 호출할 때, 앞이나 뒤에 항상 똑같은 코드가 추가로 실행된다면 반복되는 부분을 함수 안으로 옮겨준다. 이렇게 하면 문장을 수정할 일이 생겼을 때, 한 곳만 수정하면 된다.
## 4. 문장을 호출한 곳으로 옮기기  
3번과 반대 리팩토링 방법이다. 함수의 동작이 호출자에 따라서 다르게 동작하도록 바뀌어야 한다면 문장을 호출하는 곳으로 분리해서 적용해야한다.
## 5. 인라인 코드를 함수 호출로 바꾸기  
똑같은 코드가 반복된다면 함수 호출로 변경해준다. 이렇게 하면 수정 사항이 발생했을때 함수 하나만 수정하면 된다. 
## 6. 문장 슬라이드하기  
관련된 코드들이 한곳에 모여있을때 더 이해하기 쉽다. 그리고 관련된 코드들끼리 모여있을때 다른 리팩토링도 행하기 쉬워진다. 코드를 옮겼을때 부수효과가 일어난다면 이 방법을 포기한다. 

```java
BookData bookData = new BookData();
WriterData writerData = new WriterData();
...
int bookPrice = bookData.getPrice();
```  
아래처럼 변수를 사용하는 곳에서 선언하면 관련있는 코드들끼리 모을 수 있다.

```java
BookData bookData = new BookData();
int bookPrice = bookData.getPrice();
``` 

## 7. 반복문 쪼개기  
한 반복문 안에서 여러가지 일을 할때 이는 분리되어야 한다. 반복문이 두 번 실행되므로 이 방법이 불편할 수도 있지만 리팩토링과 최적화는 분리해서 생각해야 한다.  

## 8. 반복문 파이프라인으로 바꾸기  
반복문은 파이프라인을 이용해서 처리과정을 일련의 연산으로 표현할 수 있다. 
```java
List<BookData> bestSellerList = bookDataList.stream().
                                filter(b->b.getSales()>100).
                                collect(Collectors.toList());
```  
판매부수가 100부가 넘는 책을 베스트 셀러라고 할때 반복문을 돌면서 확인하지 않고 파이프라인으로 표현하면 가독성이 더 좋아진다.  

## 9. 죽은 코드 제거하기  
호출하는 곳이 없는 코드는 지워야 한다. 다시 필요해질까봐 못지우겠다면 버전 관리 프로그램을 이용하여 어느 버젼에서 삭제됐는지 메모해두면 된다.
